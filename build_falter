#!/bin/bash

# do not use 'set -e'. It will abort a whole build if, i.e. the
# memory of a single 4MB-Device exceeds.
# set -e

REALPATH_SCRIPT=$(realpath "$0")
BUILTER_DIR=$(dirname "$REALPATH_SCRIPT")

RELEASE_LINK_BASE="https://downloads.openwrt.org/releases/"

# General variables
FALTER_REPO_BASE="src/gz openwrt_falter https://firmware.berlin.freifunk.net/feed/"
FREIFUNK_RELEASE=""
OPENWRT_TOH="https://openwrt.org/_media/toh_dump_tab_separated.gz"

# list of packages, that get omitted on 8 MiB devices
OMIT_LIST_8MiB="
    mtr
    iperf3
    tmux
    vnstat
    "
# list of devices, that have technically 16 MiB flash, but have two partitions a 8 MiB
OVERRIDE_TO_8MiB="
    ubnt_unifiac-mesh
"

##################
#   CMD-PARSER   #
##################

# POSIX-compliant getopt(s)-free old-style-supporting option parser from phk@[se.unix]
# https://stackoverflow.com/a/33191693
print_usage() {
    echo "Usage:

  $0 {p|v|t|s|p|d} [ARG...]

Options:

  -p|--packageset [PATH]
    give a path to the packageset

  -v|--version [VERSION]
    Falter-release to be used. i.e. '1.1.0' or '1.1.1-snapshot', etc.
    Maps directly to the directories at https://firmware.berlin.freifunk.net/feed/

  -t|--target [TARGET]
    target like 'ath79'

  -s|--sub-target [SUBTARGET]
    something like 'generic'. This is optional.

  -r|--router [ROUTER-PROFILE]
    give a router-profile like 'glinet_gl-ar150'. This is optional.

  -l|--list-routers
    shows a list of the routers avaiable in that target and
    their profile name. This name is the input for '-r'.

  -d|--development
    use development-feeds instead of release-feeds

  -i|--image-builder
    use custom image-builder instead of standart-openwrt ones.

" >&2
}

if [ $# -le 0 ]; then
    print_usage
    exit 1
fi

opt=
while :; do

    if [ $# -le 0 ]; then
        # no parameters remaining -> end option parsing
        break
    elif [ ! "$opt" ]; then
        # we are at the beginning of a fresh block
        # remove optional leading hyphen and strip trailing whitespaces
        opt=$(echo "$1" | sed 's/^-\?\([a-zA-Z0-9\?-]*\)/\1/')
    fi

    # get the first character -> check whether long option
    first_chr=$(echo "$opt" | awk '{print substr($1, 1, 1)}')
    [ "$first_chr" = - ] && long_option=T || long_option=F

    # note to write the options here with a leading hyphen less
    # also do not forget to end short options with a star
    case $opt in
    -)
        # end of options
        shift
        break
        ;;

    d* | -development)
        echo "using dev-feeds."
        FALTER_REPO_BASE="$FALTER_REPO_BASE""new/"
        ;;

    p* | -packageset)
        if [ "$2" ]; then
            echo "Packagset is: $2"
            PARSER_PACKAGESET="$2"
            shift
        else
            echo "Packageset parameters incomplete!" >&2
            print_usage
            exit 1
        fi
        ;;

    v* | -version)
        if [ "$2" ]; then
            echo "Falter-version is: $2"
            PARSER_FALTER_VERSION="$2"
            shift
        else
            echo "Version parameters incomplete!" >&2
            print_usage
            exit 1
        fi
        ;;

    t* | -target)
        if [ "$2" ]; then
            echo "Target is: $2"
            PARSER_TARGET="$2"
            shift
        else
            echo "Target parameters incomplete!" >&2
            print_usage
            exit 1
        fi
        ;;

    s* | -sub-target)
        if [ "$2" ]; then
            echo "Sub-Target is: $2"
            PARSER_SUBTARGET="$2"
            shift
        else
            echo "Sub-Target parameters incomplete!" >&2
            print_usage
            exit 1
        fi
        ;;

    r* | -router)
        if [ "$2" ]; then
            echo "Router is: $2"
            PARSER_PROFILE="$2"
            shift
        else
            echo "router-profile parameters incomplete!" >&2
            print_usage
            exit 1
        fi
        ;;

    i*|-image-builder)
        if [ "$2" ]; then
            echo "Use Custom Imagebuilder at: $2"
            IMAGE_BUILDER_PATH="$2"
            shift
        else
            echo "Custom Imagebuilder parameters incomplete!" >&2
            print_usage
            exit 1
        fi
        ;;

    l* | -list-routers)
        PARSER_LIST_ROUTERS="y"
        ;;

    h* | \?* | -help)
        print_usage
        exit 0
        ;;

    *)

        if [ "$long_option" = T ]; then
            opt=$(echo "$opt" | awk '{print substr($1, 2)}')
        else
            opt=$first_chr
        fi
        printf 'Error: Unknown option: "%s"\n' "$opt" >&2
        print_usage
        exit 1
        ;;

    esac

    if [ "$long_option" = T ]; then
        # if we had a long option then we are going to get a new block next
        shift
        opt=

    else
        # if we had a short option then just move to the next character
        opt=$(echo "$opt" | awk '{print substr($1, 2)}')

        # if block is now empty then shift to the next one
        [ "$opt" ] || shift
    fi
done

# check if we got all options we would need.
if [ -z "$PARSER_FALTER_VERSION" ]; then echo "Please specify a falter-version with '-v'."; OPTION_MISSING=1; fi
if [ -z "$PARSER_TARGET" ]; then echo "Please give a target with '-t'."; OPTION_MISSING=1; fi
if [ -z "$PARSER_SUBTARGET" ]; then echo "Please give a subtarget with option '-s'."; OPTION_MISSING=1; fi
if [ -z "$PARSER_PACKAGESET" ]; then echo "Please specify a packageset with option '-p'."; OPTION_MISSING=1; fi
if [ "$OPTION_MISSING" == 1 ]; then echo "Exiting..."; exit 1; fi

# check for dependencies.
SCRIPT_DEPENDS="awk curl gawk grep git gettext python3 rsync sed unzip wget"
for DEP in $SCRIPT_DEPENDS; do
    type "$DEP" >/dev/null
    if [ $? != 0 ]; then
        echo "$DEP is not installed, but needed for this script."
        exit 1
    fi
done

# repository derives directly from the falter-version. Download freifunk_release
# file and determine openwrt-version by its variables
BASE_URL=$(echo "$FALTER_REPO_BASE" | cut -d' ' -f 3)
FEEDURL="$BASE_URL$PARSER_FALTER_VERSION/packages/mips_24kc/falter/"
if ! curl --silent --fail "$FEEDURL" >/dev/null; then
    echo "Error: failed retrieving feed URL. Wrong version '$PARSER_FALTER_VERSION'?"
    exit 2
fi

COMMONFILEURL=$FEEDURL$(curl -s "${FEEDURL}"/Packages | sed -n '/falter-common$/,/^$/p' | awk '{if(/Filename: /) print $2}')
TMP=$(curl -s "$COMMONFILEURL" | tar xzOf - ./data.tar.gz | tar xzOf - ./etc/freifunk_release)
eval "$TMP"

#################
#   FUNCTIONS   #
#################

function build_router_db {
    # load the table-of-hardware from openwrt project, to get further information on router,
    # like i.e. flash-size
    wget "$OPENWRT_TOH" -O "$BUILTER_DIR/build/toh.gz"
    gunzip "$BUILTER_DIR/build/toh.gz"
    echo -e '.separator "\t"\n.import '"$BUILTER_DIR/build/toh"' toh' | sqlite3 "$BUILTER_DIR/build/toh.db"
}

function request_router_from_db {
    local board="$1"
    local response

    response=$(sqlite3 -batch "$BUILTER_DIR/build/toh.db" <<EOF
SELECT
    brand, model, version, flashmb, rammb
FROM
    toh
WHERE
    firmwareopenwrtinstallurl LIKE '%$board%' OR
    firmwareopenwrtupgradeurl LIKE '%$board%' OR
    firmwareopenwrtsnapshotinstallurl LIKE '%$board%' OR
    firmwareopenwrtsnapshotupgradeurl LIKE '%$board%';
EOF
)
    # sometimes different routers share the same image
    # like UniFi AC Mesh and UniFi AC Mesh Pro. Ensure to only
    # return one dataset and take the first one then.
    echo "$response" | head -n1
}

function patch_if_needed() {
    # check if a patch has already been applied (i.e. it's been merged upstream (for some versions))
    # and apply it only if it has not
    patch -f -s -R --dry-run -p${2:-1} -i "$1" >/dev/null || \
    patch -f -p${2:-1} -i "$1"
}

function patch_buildsystem() {
    # applies some patches to the buildsystem to allow us building falter in our way.

    # patch json-info, so that it will contain every image, not just the last one
    patch_if_needed ../../patches/append_new_images_overview_json.patch
    # fix patch at building mikrotik devices. prepones https://github.com/openwrt/openwrt/pull/3262
    patch_if_needed ../../patches/workaround-kernel2minor-path-length-limitation.patch 2
}

function derive_packagelist_version {
    # OpenWrt-Version from freifunk-release file could be something like
    # '19.07-SNAPSHOT'. But we have only packagelists for 19.07... Solve that.
    regex="^[0-9][0-9].[0-9][0-9]"
    if [[ $1 =~ $regex ]]; then
        echo $(echo $1 | cut -c 1-5)
    else
        echo "snapshot"
    fi
}

function read_packageset {
    local PACKAGE_SET_PATH=$1
    # read packageset, while removing comments, empty lines and newlines
    PACKAGE_SET=$(cat "$PACKAGE_SET_PATH" | sed -e '/^#/d; /^[[:space:]]*$/d' | tr '\n' ' ')
}

function fetch_subdirs {
    URL=$1
    curl -s "$URL" | grep href | grep -v 'snapshots\|releases' | awk -F'"' '{print $4}'
}

function is_wave1_device {
    # detect, if a device has wave1-chipset by its firmware
    local profile=$1
    DEVICE_PACKAGES=$(make info | grep "$profile:" -A 2 | tail -n1 | cut -d':' -f2)
    if [[ "$DEVICE_PACKAGES" =~ ath10k-firmware-qca988x || "$DEVICE_PACKAGES" =~ ath10k-firmware-qca9887 ]]; then
        subsitute_ct_driver "$DEVICE_PACKAGES"
    else
        PACKAGE_SET_DEVICE="$PACKAGE_SET"
    fi
}

function subsitute_ct_driver {
    # generate a packagelist with ct-drivers/firmware substituted by normal one
    local DEVICE_PACKAGES="$@"
    echo "wave1 chipset detected..."
    echo "change firmware and drivers in packagelist to non-ct counterparts..."
    PACKAGE_SET_DEVICE=$(echo "$PACKAGE_SET"" $DEVICE_PACKAGES" | sed -e 's/ath10k-firmware-qca988x-ct/ath10k-firmware-qca988x -ath10k-firmware-qca988x-ct/g; s/ath10k-firmware-qca9887-ct/ath10k-firmware-qca9887 -ath10k-firmware-qca9887-ct/g; s/kmod-ath10k-ct/kmod-ath10k -kmod-ath10k-ct/g')
}

function is_8MiB_flash_device {
    # remove some packages to keep the image-size quite below 8MiB
    local profile="$1"
    local DEVICE_PACKAGES=$(echo "$@" | cut -d' ' -f 2-)
    local flash

    flash=$(request_router_from_db "$profile" | cut -d'|' -f 4)

    # fail on purpose, if field didn't contain integer only
    # enforce 8MiB-List, if Router was specified in override-list
    if [ "$flash" -le 8 ] || [[ $OVERRIDE_TO_8MiB == *$profile* ]]; then
        echo "Board has 8MiB flash only. Removing some packages..."

        for P in $OMIT_LIST_8MiB; do
            PACKAGE_SET_DEVICE=$(echo "$PACKAGE_SET_DEVICE" | sed -e "s|$P||g")
        done
    fi
}

function is_32MiB_RAM_device {
    echo "is_32MiB_RAM_device: Not implemented now"
    exit 42
}

function modify_packagelist {
    local profile="$1"

    # $PACKAGE_SET and $PACKAGE_SET_DEVICE are global variables holding the
    # original and the per device modified packagelist. They get modified by the
    # functions directly
    is_wave1_device "$profile"
    is_8MiB_flash_device "$profile" "$PACKAGE_SET_DEVICE"
}

function derive_branch_from_url {
    URL=$1
    RELEASE_TYPE=$(echo "$URL" | awk -F'/' '{print $4}')
    case $RELEASE_TYPE in
    releases)
        echo "$URL" | awk -F'/' '{print $5}' | cut -d. -f1-2
        ;;
    snapshots)
        echo snapshot
        ;;
    esac
}

function generate_embedded_files {
    FALTERBRANCH="$1"
    local url="$2"
    local fingerprint="$3"
    # call scripts to generate dynamic data in embedded files
    local TARGET=$(echo $IMAGE_BUILDER_URL | cut -d'/' -f 7)
    local SUBTARGET=$(echo $IMAGE_BUILDER_URL | cut -d'/' -f 8)

    local OPENWRT_BASE=$(echo $IMAGE_BUILDER_URL | cut -d'/' -f 5)
    echo "OPENWRT_BASE $OPENWRT_BASE"

    # Get the FREIFUNK_RELEASE variable from the falter feed
    # located in the falter-common package.
    [ "snapshot" == $FALTERBRANCH ] && FALTERBRANCH="master"
    [ $FALTERBRANCH != "master" ] && FALTERBRANCH="openwrt-$PARSER_OWT"

    # clear out any old embedded_files
    rm -rf ../../embedded-files/*

    ../../scripts/01-generate_banner.sh $FREIFUNK_RELEASE $TARGET $SUBTARGET $FREIFUNK_REVISION
    ../../scripts/02-favicon.sh
    ../../scripts/03-luci-footer.sh $FREIFUNK_RELEASE $TARGET $SUBTARGET $FALTERBRANCH $FREIFUNK_REVISION
    export REPO # export repo line to inject into images. contains whitespace...
    ../../scripts/04-include-falter-feed.sh "$url" "$fingerprint"
    ../../scripts/05-olsrd-init-for-21-02-0.sh $OPENWRT_BASE
    ../../scripts/06-luci-base-networkjs.sh $OPENWRT_BASE
}

function start_build {
    # use local imagebuilder if it was given
    echo "$IMAGE_BUILDER_PATH"
    echo "$1"

    if [ -n "$IMAGE_BUILDER_PATH" ]; then
      IMAGE_BUILDER_URL=$IMAGE_BUILDER_PATH
    else
      IMAGE_BUILDER_URL="$1"
    fi

    local TMP=$2 # slice packageset-name from path
    local PKG_SET=$(echo $TMP | rev | cut -d'/' -f1 | rev | cut -d'.' -f1)
    local DEVICE=$3

    FILENAME=$(basename $IMAGE_BUILDER_URL)
    FOLDERNAME=$(basename $FILENAME .tar.xz)
    BRANCH=$(derive_branch_from_url $IMAGE_BUILDER_URL)
    [ -z $BRANCH ] && BRANCH="snapshot"

    echo "building using: $IMAGE_BUILDER_URL"
    echo "selected branch: $BRANCH"
    echo "FILENAME $FILENAME FOLDERNAME $FOLDERNAME BRANCH $BRANCH PKG_SET $PKG_SET"

    if [ -z $IMAGE_BUILDER_PATH ]; then
      # store imagebuilders in cache. Reload, if there is a newer version avaiable
      local CACHE="../imagebuilder_cache"
      if [ ! -d $CACHE ]; then mkdir -p $CACHE; fi
      cd $CACHE
      wget -N --no-if-modified-since $IMAGE_BUILDER_URL
      cd ../build
      # pull imagebuilder from cache-dir
      cp ../imagebuilder_cache/$FILENAME $FILENAME
    else
      cp ../$IMAGE_BUILDER_PATH $FILENAME
    fi

    echo $PWD
    echo "Extracting imagebuilder..."

    rm -rf $FOLDERNAME ib
    tar -xJf $FILENAME
    mv $FOLDERNAME ib
    FOLDERNAME="ib"
    echo "done."

    cd $FOLDERNAME
    echo "start patching imagebuilder..."
    patch_buildsystem
    echo "done."

    if [ "$PARSER_LIST_ROUTERS" == "y" ]; then
        # if ask for, show avaiable router-profiles and quit
        make info | sed -e '/Packages:/d;/hasImageMetadata:/d'
        exit 0
    fi

    # Target is in different position in the URL, depending on the OpenWrt version.
    case $BRANCH in
    snapshot)
        ispos=7
        ;;
    *)
        ispos=8
        ;;
    esac
    # when using custom imagebuilder, the target is on 8th position everytime.
    if [ -n "$IMAGE_BUILDER_PATH" ]; then
        ispos=8
    fi

    INSTR_SET=$(grep "openwrt_base" repositories.conf | awk -F'/' "{print \$$ispos}")
    echo "selected instruction set: $INSTR_SET"

    REPO="$FALTER_REPO_BASE/$PARSER_FALTER_VERSION/packages/$INSTR_SET/falter"
    echo "injecting repo line: $REPO"
    echo "$REPO" >>repositories.conf

    # the hexadecimal number represents the fringerprint of the key. Refer to third section of https://openwrt.org/docs/guide-user/security/keygen#generate_usign_key_pair
    local URL="https://firmware.berlin.freifunk.net/feed/packagefeed_master.pub"
    local FINGERPRINT="61a078a38408e710"
    echo "loading package-feed key from $URL"
    mkdir -p keys
    curl "$URL" >"keys/$FINGERPRINT"
    # check, if we really got a key
    grep "untrusted comment:" "keys/$FINGERPRINT" >/dev/null
    if [ $? != 0 ]; then
        echo -e "\nThe loaded file apparently doesn't contain a valid key!\n"
        exit 2
    fi

    generate_embedded_files "$BRANCH" "$URL" "$FINGERPRINT"
    if [ -z "$DEVICE" ]; then
        for profile in $(make info | grep ":$" | cut -d: -f1 | grep -v "Available Profiles" | grep -v "Default"); do
            echo "start building $profile..."

            modify_packagelist "$profile"

            make image PROFILE="$profile" PACKAGES="$PACKAGE_SET_DEVICE" FILES="../../embedded-files/" EXTRA_IMAGE_NAME="freifunk-falter-${FREIFUNK_RELEASE}"
            PACKAGE_SET_DEVICE="" # empty packageset for use with next wave1-device
            echo "finished."
        done
    else
        echo "start building $DEVICE..."

        modify_packagelist "$DEVICE"

        make image PROFILE="$DEVICE" PACKAGES="$PACKAGE_SET_DEVICE" FILES="../../embedded-files/" EXTRA_IMAGE_NAME="freifunk-falter-${FREIFUNK_RELEASE}"
        PACKAGE_SET_DEVICE=""
    fi
    # move binaries into central firmware-dir, sort them for packagesets, there was given one.
    if [ "$PKG_SET" ]; then
        rsync -a --remove-source-files bin/targets/* ../../firmwares/$PKG_SET/
    else
        rsync -a --remove-source-files bin/targets/* ../../firmwares/
    fi

    cd ..
}

##############
#    MAIN    #
##############

PARSER_OWT=$(derive_packagelist_version $FREIFUNK_OPENWRT_BASE)

if [ "$PARSER_PACKAGESET" == "all" ]; then
    # build all imageflavours. For this, get paths of packagesets
    # fetch paths of packagelists (depends on openwrt-version). If not unique, chose most recent version of possibilities.
    PSET_PATHS=$(find packageset | sort | grep -e "/$PARSER_OWT" | grep .txt | tail -n3)
    echo $PSET_PATHS
    #exit
else
    read_packageset "$PARSER_PACKAGESET"
fi

# remove artifacts of last build
mkdir -p firmwares
rm -rf firmwares/*
mkdir -p build
rm -rf build/*
sleep 3 # avoid strange issues with database...
cd build

# read command-line parameters
CONF_RELEASE="$PARSER_OWT"
CONF_TARGET="$PARSER_TARGET"
CONF_SUBTARGET="$PARSER_SUBTARGET"
CONF_DEVICE="$PARSER_PROFILE"

# get OpenWrt ToH
build_router_db

# if openwrt_base is "master": change to "snapshots". That is the correct
# directory for downloading openwrt-master
if [ $FREIFUNK_OPENWRT_BASE == "master" ]; then
    RELEASE_LINK_BASE="https://downloads.openwrt.org/"
    FREIFUNK_OPENWRT_BASE="snapshots"
fi

if [ -z "$CONF_TARGET" ] && [ -z "$IMAGE_BUILDER_PATH" ]; then
    # build one release for all targets
    RELEASE_LINK="$RELEASE_LINK_BASE""$FREIFUNK_OPENWRT_BASE""/targets/"
    for target in $(fetch_subdirs "$RELEASE_LINK"); do
        for subtarget in $(fetch_subdirs $RELEASE_LINK$target); do
            imagebuilder=$(fetch_subdirs $RELEASE_LINK$PARSER_PROFILE$target$subtarget | grep imagebuilder)
            start_build $RELEASE_LINK$target$subtarget$imagebuilder
        done
    done
    exit
else
    # there was given a release and a target
    RELEASE_LINK="$RELEASE_LINK_BASE""$FREIFUNK_OPENWRT_BASE""/targets/"
    # if there was defined a subtarget and option device, only build that.
    if [ -n "$CONF_SUBTARGET" ] || [ -n "$IMAGE_BUILDER_PATH" ]; then
        # build directly that subtarget. if requested, for all image types.
        TARGET_LIST="$RELEASE_LINK$CONF_TARGET/$CONF_SUBTARGET/"
        IMAGEBUILDER=$(fetch_subdirs "$TARGET_LIST" | grep imagebuilder)
        if [ "$PSET_PATHS" ]; then
            for PKG_SET in $PSET_PATHS; do
                echo "building three packagelists..."
                read_packageset "../$PKG_SET"
                start_build "$TARGET_LIST$IMAGEBUILDER" $PKG_SET $CONF_DEVICE
            done
        else
            echo "building one packagelist only..."
            # "targets" is on purpose there. Otherwise that positonal argument would be empty.
            start_build "$TARGET_LIST$IMAGEBUILDER" targets $CONF_DEVICE
        fi
        exit
    fi
    # otherwise, fetch all subtargets and build them one after another.
    for subtarget in $(fetch_subdirs "$RELEASE_LINK$CONF_TARGET/"); do
        imagebuilder=$(fetch_subdirs "$RELEASE_LINK$CONF_TARGET/$subtarget" | grep imagebuilder)
        if [ "$PSET_PATHS" ]; then
            for PKG_SET in $PSET_PATHS; do
                echo "building three packagelists..."
                read_packageset "../$PKG_SET"
                start_build "$RELEASE_LINK$CONF_TARGET/$subtarget$imagebuilder" $PKG_SET
            done
        else
            echo "building one packagelist only..."
            start_build "$RELEASE_LINK$CONF_TARGET/$subtarget$imagebuilder"
        fi
    done
    exit
fi
